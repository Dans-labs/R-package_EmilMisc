% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Devel.R
\name{mod}
\alias{mod}
\alias{\%mod\%}
\title{Modulo-operator with near-equality}
\usage{
`\%mod\%`(x, y, tolerance = sqrt(.Machine$double.eps))
x \%mod\% y
}
\arguments{
\item{x, y}{numeric vectors, similar to those passed on to \%\%}

\item{tolerance}{numeric, maximum difference, see \code{\link[base]{all.equal}}. The default is ~ \code{1.5e-8}}
}
\value{
identical to the result for \%\%, unless the answer would be really close to y, in which case 0 is returned
}
\description{
The \code{\link[base:Arithmetic]{`\%\%`}} operator calculates the modulo, but sometimes has rounding errors, e.g. "\code{(9.1/.1) \%\% 1}" gives ~ 1, instead of 0.\cr
Comparable to what all.equal does, this operator has some tolerance for small rounding errors.\cr
If the answer would be equal to the divisor within a small tolerance, 0 is returned instead.
}
\details{
For integer x and y, the normal \%\%-operator is used
}
\note{
To specify tolerance, use the call \code{`\%mod\%`(x,y,tolerance)}

The precedence for \code{\%mod\%} is the same as that for \code{\%\%}
}
