% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Misc.R
\name{LazyAnd}
\alias{LazyAnd}
\alias{LazyOr}
\title{Lazy (short-circuited), vectorized &/&& and |/||}
\usage{
LazyAnd(a, b, fun, ...)

LazyOr(a, b, fun, ...)
}
\arguments{
\item{a}{A logical}

\item{b}{A vector equal to length of a (unless length(a)==1), which is used if a evaluates to TRUE or NA (for LazyAnd), or if a evaluates to FALSE or NA (for LazyOr)}

\item{fun}{Function to be called. Note that this function needs fun(b[x]) to be independent of fun(b[y])}

\item{...}{Additional arguments to be passed on to fun}
}
\value{
LazyAnd: \code{a & fun(b)}, but fun(b) is only called for those b[x] where \code{a[x]==TRUE || is.na(a[x])}\cr\cr
LazyOr: \code{a | fun(b)}, but fun(b) is only called for those b[x] where \code{a[x]==FALSE || is.na(a[x])}
}
\description{
In base R, & is vectorized, and && is short-circuited (also called lazy evaluation).
LazyAnd combines these two: a is evaluated, and then fun(b) is called for the positions where a evaluates to TRUE (or NA), to decide a & b.
The advantage is that it's possible to check for valid inputs and use these inputs in one go, or that it's possible to only call an expensive function when needed.\cr\cr
LazyOr is analogous, fun(b) only called if a is FALSE or NA
}
\section{Warning}{

Note that this may produce unexpected results if elements of fun(b) are not independent of each other, e.g. calling: \cr
\code{
nums <- 1:10
nums \%\% 2==0 & cumsum(nums) \%\% 2==0
}\cr\cr
and\cr\cr
\code{
LazyAnd(nums \%\% 2==0, nums, function(x) {cumsum(x) \%\% 2==0})
}\cr\cr
gives different results, as \code{cumsum(1:10[c(2,4,6,8,10)]}) is called, instead of \code{cumsum(1:10)[c(2,4,6,8,10)]}, which produces different results
}

\examples{
# A function to check evenness, but who prints an alert if the value is more then 10
input <- data.frame(valid=c(TRUE,TRUE,TRUE,TRUE,FALSE,FALSE),
value=c('1','12',2,'3','huh',14), stringsAsFactors = FALSE)
fun <- function(x) {
  if(any(as.numeric(x)>10))
    cat('Numbers over 10 (unexpected):',as.numeric(x)[as.numeric(x)>10], '')
  return(as.numeric(x) \%\% 2==0)
}
cat("\\nAnd in total we have",sum(input$valid & fun(input$value)),"even numbers")
cat("\\nWith LazyAnd we have in total:",sum(LazyAnd(input$valid, input$value, fun)),"even numbers")

# Example where calling a function for all possible values would be possible,
# but (prohibitively) expensive
set.seed(4)
# This function may be very expensive, so we don't want to check all numbers
is.prime <- function(n) n == 2L || all(n \%\% 2L:max(2,floor(sqrt(n))) != 0)
n <- floor(runif(1e4, min=0, max=.5)^(-4))
surely_prime <- LazyAnd(n<1e10, n, sapply, FUN=is.prime)

# The difference between this call and
\dontrun{sapply(n, is.prime) # Don't try this at home!}
# is getting results for 62 more occurences (with low probability of being prime,
# probably 2-3 of them are prime), at the cost of a LOT of resources.

}
